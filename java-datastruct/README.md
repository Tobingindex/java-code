# 数据结构

## 树

树一种非线性结构，树的家族中，主要有二叉搜索树、平衡二叉树、红黑树以及递归树。

在一棵树中，一个节点可以有多个子节点，一个子节点仅能有一个父节点，同一个父节点的若干节点之间互称为**兄弟节点**。把没有父节点的节点叫做**根节点**，把没有子节点的节点叫做**叶子节点**。

在树中，有几个比较相似的概念：

+ 节点的高度：节点到叶子节点的最长路径（从下往上度量）
+ 节点深度：根节点到这个节点记录的边的个数（从上往下的度量）
+ 节点的层：节点的深度+1
+ 树的高度：根节点的高度

### 二叉树 

二叉树(Binary Tree)中，每个节点最多有两个子节点，分别是**左子节点**和**右子节点**。二叉树并不要求每个节点都有两个子节点，有的节点只有左子节点，有的节点只有右子节点。

二叉树中，有两种比较特殊的二叉树：**满二叉树**和**完全二叉树**

+ 满二叉树：叶子节点全部都在底层，除了叶子节点之外，每个节点都有左右两个子节点
+ 完全二叉树：叶子节点在最底下两层，最后一层的叶子节点都靠走排列，并且处理最后一层，其他层的节点个数都要达到最大。

满二叉树特征明显， 因此会通过一个单独的概念来描述。相比之下，完全二叉树的特征就显得没有这么明显。之所以单独使用完全二叉树这个概念来单独描述一种二叉树，是因为这种二叉树比较特殊的特性，涉及到二叉树的储存。

#### 二叉树储存

二叉树的储存可以有两种方式，一种是基于指针或引用的**二叉链式储存法**，一种是基于数组的**顺序存储法**。

**链式存储法**简单、直观。每个节点有三个字段，其中一个储存数据，另外两个是指向左右子节点的指针。通过根节点可以通过左右子节点的指针把整棵树串起来。

```java
class Node {
    private Object e;
    private Node left, right;
}
```

**顺序存储法**基于数组实现。它把根节点储存到下标为` i=1 `的位置，左节点储存到下标为` 2*i=2 `的位置，右节点储存到下标为 `2*i+1=3 `的位置。以此类推，左节点的左子节点储存在`2*i=2*2=4` 的位置，右节点储存在`2*i+1=2*2+1=5`的位置。

在使用顺序存储法的时候，如果储存的一个树是完全二叉树，那么它**浪费**的空间仅仅是下标为0的储存位置。如果是非完全二叉树，将会浪费比较多的数组存储空间。

综上所述，如果某棵二叉树是一棵完全二叉树，那用数组存储无疑是最节省内存的一种方式。因为数组的存储方式并不需要像链式存储法那样，要**存储额外的左右子节点的指针**。这也是为什么完全二叉树会单独拎出来的原因，也是为什么完全二叉树要求最后一层的子节点都靠左的原因。  

#### 二叉树遍历

二叉树的经典遍历算法有三种：**前序遍历**，**中序遍历**和**后序遍历**。

+ 前序遍历：对于树中的任意节点来说，先打印这个节点，然后再打印它的左子树，最后打印它的右子树。
+ 中序遍历：对于树中的任意节点来说，先打印它的左子树，然后再打印它本身，最后打印它的右子树。
+ 后序遍历：对于树中的任意节点来说，先打印它的左子树，然后再打印它的右子树，最后打印这个节点本身。  

实际上，二叉树的前、中、后序遍历就是一个递归的过程。比如，前序遍历，其实就是先打印根节点，然后再递归地打印左子树，最后递归地打印右子树。  

在前、中、后序遍历中，每个节点最多被访问两次，因此遍历操作的时间复杂，跟根节点个树n成正比，即二叉树遍历的时间复杂度为O(n)。

> 前序遍历，中序遍历，后序遍历的输出序列特点

```bash

```



### 二叉查找树

二叉查找树(Binary Search Tree)是二叉树中最常用的一种类型，也叫二叉搜索树,是为了实现**快速查找**而生的。但是，它不仅仅支持快速查找一个数据，还支持快速插入、删除一个数据。

**二叉查找树要求，在树中的任意一个节点，其左子树中的每个节点的值，都要小于这个节点的值，而右子树节点的值都大于这个节点的值。**  

#### BST 查找操作

在二叉查找树中查找一个节点。

先取根节点，如果它等于我们要查找的数据，那就返回。

如果要查找的数据比根节点的值小，那就在左子树中递归查找；

如果要查找的数据比根节点的值大，那就在右子树中递归查找。  

#### BST 插入操作

插入过程类似于查找过程。新插入的节点一般都是在叶子节点上，在插入时只需要从根节点，依次比较要插入的数据和节点的大小关系。
如果要插入的数据比节点的数据大，并且节点的右子树为空，就将新数据直接插到右子节点
的位置；如果不为空，就再递归遍历右子树，查找插入位置。

同理，如果要插入的数据比节点数值小，并且节点的左子树为空，就将新数据插入到左子节点的位置；如果不为空，就再递归遍历左子树，查找插入位置。  

#### BST 删除操作

<font style="color:red">**删除操作比较复杂。**</font>针对要删除节点的子节点个数不同，需要分三种情况处理。

+ 删除的节点没有子节点，直接将父节点中，指向删除节点的指针置为null即可；
+ 删除的节点的节点只有一个子节点（左/右），只需要更新父节点中，指向要删除节点的指针，让它指向删除节点的子节点即可；
+ 删除的节点的节点有两个子节点，这种情况比较复复杂。需要先找到这个节点的最小节点，把它替换到删除的节点。再删除这个最小节点，因为最小节点肯定没有左子节点（如果有就不是最小子节点了），因此，可以应用上述的两条规则来删除这个最小节点。

关于BST的输出操作，还有一个比较简单、取巧的方法，就是单纯将要删除的节点**标记**为“已删除”，但并不真正从树中将这个节点去掉。这样一来就不需要执行上述的操作，同时这种方式也没有增加插入、查找操作代码实现的难度。这种方式的唯一缺点就是比较浪费内存空间。

#### BST 其他操作

除了插入、删除、查找，BST还支持**快速地查找最大节点和最小节点、前驱节点和后继节点**。  除此之外，BST还有一个重要的特性，即

<font style="color:red">**中序遍历二叉查找树，可以输出有序的数据序列，时间复杂度是 O(n)，非常高效。因此，二叉查找树也叫作二叉排序树。**  </font>

#### BST 支持重复数据

在实际的软件开发中，BST储存的是包含很多字段的对象。利用对象的某个字段作为键值(key)来构建二叉树。这种情况下，把对象汇总其他字段叫做**卫星数据**。

为了能够储存重复数据，可以有两种解决方法。

+ 第一种比较简单。二叉查找树中每一个节点不仅会存储一个数据，因此我们通过链表和
  支持动态扩容的数组等数据结构，把值相同的数据都存储在同一个节点上。

+ 第二种方法比较不好理解，不过更加优雅。  每个节点仍然只存储一个数据。在查找插入位置的过程中，如果碰到一个节点的值，与要插入数据的值相同，我们就将这个要插入的数据放到这个节点的右子树，也就是说，把这个新插入的数据当作大于这个节点的值来处理。  

  这种情况下，当要查找数据的时候，遇到值相同的节点，我们并不停止查找操作，而是继续在右子树中查找，直到遇到叶子节点，才停止。这样就可以把键值等于要查找值的所有节点都找出来。

  对于删除操作，我们也需要先查找到每个要删除的节点，然后再按前面讲的删除操作的方法，依次删除。  

#### BST 时间复杂度分析

实际上，二叉查找树的形态各式各样。它们的查找、插入、删除操作的执行效率都是不一样的。有的叉查找树，根节点的左右子树极度不平衡，退化成了链表，所以查找的时间复杂度就变成了O(n)。  对于完全二叉树、满二叉树，他们的查找、插入、删除操作也会发生相应的变化。

从上面来看，<font style="color:red">**不管操作是插入、删除还是查找，时间复杂度其实都跟树的高度成正比，也就是 O(height)。**  </font>这样一来，就**可以把求时间复杂度问题，转换为求一颗包含n个节点的完全二叉树的高度。**

#### BST 存在意义

散列表的插入、删除、查找操作的时间复杂度可以做到常量级的O(1)，非常高效。而二叉查找树在比较平衡的情况下，插入、删除、查找操作时间复杂度才是 O(logn)  ，相对散列表，好像并没有什么优势，那我们为什么还要用二叉查找树呢？  

主要有下面几个原因：

+ 散列表的数据时无序储存的，如果要输出有序数据，需要先排序。对于BST，只需要中序遍历可以**在O(n)时间复杂度输出有序的数据序列**。
+ 散列表扩容耗时多，且当遇到散列冲突时，性能不稳定，尽管BST不稳定，但是工程中，**最常用的平衡BST性能非常稳定，时间复杂度稳定在O(logN)**。
+ 笼统来讲，尽管散列表的查找等操作的时间复杂度是常量级的，但因为哈希冲突的存在，这个常量不一定比 logN 小，所以实际的查找速度可能不一定比 O(logN) 快。加上哈希函数的耗时，也不一定就比平衡二叉查找树的效率高。
+ **散列表的构造比二叉查找树要复杂，需要考虑的东西很多。**比如散列函数的设计、冲突解决办法、扩容、缩容等。平衡二叉查找树只需要考虑平衡性这一个问题，而且这个问题的解决方案比较成熟、固定。  
+ 为了避免过多的散列冲突，散列表装载因子不能太大，特别是基于开放寻址法解决冲突的散列表，不然**会浪费一定的存储空间**。  

#### BST 代码实现

+ [插入](https://github.com/Tobingindex/java-code/blob/master/java-datastruct/src/main/java/top/tobing/tree/binary_search_tree/BST.java#L65)
+ [包含](https://github.com/Tobingindex/java-code/blob/master/java-datastruct/src/main/java/top/tobing/tree/binary_search_tree/BST.java#L91)
+ [前序遍历【递归】](https://github.com/Tobingindex/java-code/blob/master/java-datastruct/src/main/java/top/tobing/tree/binary_search_tree/BST.java#L118)
+ [中序遍历【递归】](https://github.com/Tobingindex/java-code/blob/master/java-datastruct/src/main/java/top/tobing/tree/binary_search_tree/BST.java#L140)
+ [后序遍历【递归】](https://github.com/Tobingindex/java-code/blob/master/java-datastruct/src/main/java/top/tobing/tree/binary_search_tree/BST.java#L163)
+ [前序遍历【非递归】](https://github.com/Tobingindex/java-code/blob/master/java-datastruct/src/main/java/top/tobing/tree/binary_search_tree/BST.java#L186)
+ [中序遍历【非递归】](https://github.com/Tobingindex/java-code/blob/master/java-datastruct/src/main/java/top/tobing/tree/binary_search_tree/BST.java#L218)
+ [后序遍历【非递归】](https://github.com/Tobingindex/java-code/blob/master/java-datastruct/src/main/java/top/tobing/tree/binary_search_tree/BST.java#L212)
+ [层序遍历 ](https://github.com/Tobingindex/java-code/blob/master/java-datastruct/src/main/java/top/tobing/tree/binary_search_tree/BST.java#L224)
+ [获取最大值](https://github.com/Tobingindex/java-code/blob/master/java-datastruct/src/main/java/top/tobing/tree/binary_search_tree/BST.java#L260)
+ [获取最小值](https://github.com/Tobingindex/java-code/blob/master/java-datastruct/src/main/java/top/tobing/tree/binary_search_tree/BST.java#L249)
+ [删除最大值](https://github.com/Tobingindex/java-code/blob/master/java-datastruct/src/main/java/top/tobing/tree/binary_search_tree/BST.java#L316)
+ [删除最小值](https://github.com/Tobingindex/java-code/blob/master/java-datastruct/src/main/java/top/tobing/tree/binary_search_tree/BST.java#L224)
+ [删除任意元素](https://github.com/Tobingindex/java-code/blob/master/java-datastruct/src/main/java/top/tobing/tree/binary_search_tree/BST.java#L342)

